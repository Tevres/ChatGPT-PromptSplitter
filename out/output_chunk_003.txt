nguage by treating the surroundings as a part of the language as well.[48]  The look-ahead assertions (?=...) and (?!...) have been attested since at least 1994, starting with Perl 5.[47] The lookbehind assertions (?<=...) and (?<!...) are attested since 1997 in a commit by Ilya Zakharevich to Perl 5.005.[49] Implementations and running times  There are at least three different algorithms that decide whether and how a given regex matches a string.  The oldest and fastest relies on a result in formal language theory that allows every nondeterministic finite automaton (NFA) to be transformed into a deterministic finite automaton (DFA). The DFA can be constructed explicitly and then run on the resulting input string one symbol at a time. Constructing the DFA for a regular expression of size m has the time and memory cost of O(2m), but it can be run on a string of size n in time O(n). Note that the size of the expression is the size after abbreviations, such as numeric quantifiers, have been expanded.  An alternative approach is to simulate the NFA directly, essentially building each DFA state on demand and then discarding it at the next step. This keeps the DFA implicit and avoids the exponential construction cost, but running cost rises to O(mn). The explicit approach is called the DFA algorithm and the implicit approach the NFA algorithm. Adding caching to the NFA algorithm is often called the "lazy DFA" algorithm, or just the DFA algorithm without making a distinction. These algorithms are fast, but using them for recalling grouped subexpressions, lazy quantification, and similar features is tricky.[50][51] Modern implementations include the re1-re2-sregex family based on Cox's code.  The third algorithm is to match the pattern against the input string by backtracking. This algorithm is commonly called NFA, but this terminology can be confusing. Its running time can be exponential, which simple implementations exhibit when matching against expressions like (a|aa)*b that contain both alternation and unbounded quantification and force the algorithm to consider an exponentially increasing number of sub-cases. This behavior can cause a security problem called Regular expression Denial of Service (ReDoS).  Although backtracking implementations only give an exponential guarantee in the worst case, they provide much greater flexibility and expressive power. For example, any implementation which allows the use of backreferences, or implements the various extensions introduced by Perl, must include some kind of backtracking. Some implementations try to provide the best of both algorithms by first running a fast DFA algorithm, and revert to a potentially slower backtracking algorithm only when a backreference is encountered during the match. GNU grep (and the underlying gnulib DFA) uses such a strategy.[52]  Sublinear runtime algorithms have been achieved using Boyer-Moore (BM) based algorithms and related DFA optimization techniques such as the reverse scan.[53] GNU grep, which supports a wide variety of POSIX syntaxes and extensions, uses BM for a first-pass prefiltering, and then uses an implicit DFA. Wu agrep, which implements approximate matching, combines the prefiltering into the DFA in BDM (backward DAWG matching). NR-grep's BNDM extends the BDM technique with Shift-Or bit-level parallelism.[54]  A few theoretical alternatives to backtracking for backreferences exist, and their "exponents" are tamer in that they are only related to the number of backreferences, a fixed property of some regexp languages such as POSIX. One naive method that duplicates a non-backtracking NFA for each backreference note has a complexity of ⁠ O ( n 2 k + 2 ) {\displaystyle {\mathrm {O} }(n^{2k+2})}⁠ time and ⁠ O ( n 2 k + 1 ) {\displaystyle {\mathrm {O} }(n^{2k+1})}⁠ space for a haystack of length n and k backreferences in the RegExp.[55] A very recent theoretical work based on memory automata gives a tighter bound based on "active" variable nodes used, and a polynomial possibility for some backreferenced regexps.[56] Unicode  In theoretical terms, any token set can be matched by regular expressions as long as it is pre-defined. In terms of historical implementations, regexes were originally written to use ASCII characters as their token set though regex libraries have supported numerous other character sets. Many modern regex engines offer at least some support for Unicode. In most respects it makes no difference what the character set is, but some issues do arise when extending regexes to support Unicode.      Supported encoding. Some regex libraries expect to work on some particular encoding instead of on abstract Unicode characters. Many of these require the UTF-8 encoding, while others might expect UTF-16, or UTF-32. In contrast, Perl and Java are agnostic on encodings, instead operating on decoded characters internally.     Supported Unicode range. Many regex engines support only the Basic Multilingual Plane, that is, the characters which can be encoded with only 16 bits. Currently (as of 2016) only a few regex engines (e.g., Perl's and Java's) can handle the full 21-bit Unicode range.     Extending ASCII-oriented constructs to Unicode. For example, in ASCII-based implementations, character ranges of the form [x-y] are valid wherever x and y have code points in the range [0x00,0x7F] and codepoint(x) ≤ codepoint(y). The natural extension of such character ranges to Unicode would simply change the requirement that the endpoints lie in [0x00,0x7F] to the requirement that they lie in [0x0000,0x10FFFF]. However, in practice this is often not the case. Some implementations, such as that of gawk, do not allow character ranges to cross Unicode blocks. A range like [0x61,0x7F] is valid since both endpoints fall within the Basic Latin block, as is [0x0530,0x0560] since both endpoints fall within the Armenian block, but a range like [0x0061,0x0532] is invalid since it includes multiple Unicode blocks. Other engines, such as that of the Vim editor, allow block-crossing but the character values must not be more than 256 apart.[57]     Case insensitivity. Some case-insensitivity flags affect only the ASCII characters. Other flags affect all characters. Some engines have two different flags, one for ASCII, the other for Unicode. Exactly which characters belong to the POSIX classes also varies.     Cousins of case insensitivity. As ASCII has case distinction, case insensitivity became a logical feature in text searching. Unicode introduced alphabetic scripts without case like Devanagari. For these, case sensitivity is not applicable. For scripts like Chinese, another distinction seems logical: between traditional and simplified. In Arabic scripts, insensitivity to initial, medial, final, and isolated position may be desired. In Japanese, insensitivity between hiragana and katakana is sometimes useful.     Normalization. Unicode has combining characters. Like old typewriters, plain base characters (white spaces, punctuation characters, symbols, digits, or letters) can be followed by one or more non-spacing symbols (usually diacritics, like accent marks modifying letters) to form a single printable character; but Unicode also provides a limited set of precomposed characters, i.e. characters that already include one or more combining characters. A sequence of a base character + combining characters should be matched with the identical single precomposed character (only some of these combining sequences can be precomposed into a single Unicode character, but infinitely many other combining sequences are possible in Unicode, and needed for various languages, using one or more combining characters after an initial base character; these combining sequences may include a base character or combining characters partially precomposed, but not necessarily in canonical order and not necessarily using the canonical precompositions). The process of standardizing sequences of a base character + combining characters by decomposing these canonically equivalent sequences, before reordering them into canonical order (and optionally recomposing some combining characters into the leading base character) is called normalization.     New control codes. Unicode introduced, among other codes, byte order marks and text direction markers. These codes might have to be dealt with in a special way.     Introduction of character classes for Unicode blocks, scripts, and numerous other character properties. Block properties are much less useful than script properties, because a block can have code points from several different scripts, and a script can have code points from several different blocks.[58] In Perl and the java.util.regex library, properties of the form \p{InX} or \p{Block=X} match characters in block X and \P{InX} or \P{Block=X} matches code points not in that block. Similarly, \p{Armenian}, \p{IsArmenian}, or \p{Script=Armenian} matches any character in the Armenian script. In general, \p{X} matches any character with either the binary property X or the general category X. For example, \p{Lu}, \p{Uppercase_Letter}, or \p{GC=Lu} matches any uppercase letter. Binary properties that are not general categories include \p{White_Space}, \p{Alphabetic}, \p{Math}, and \p{Dash}. Examples of non-binary properties are \p{Bidi_Class=Right_to_Left}, \p{Word_Break=A_Letter}, and \p{Numeric_Value=10}.  Language support  Most general-purpose programming languages support regex capabilities, either natively or via libraries. Uses 	 This section needs additional citations for verification. Please help improve this article by adding citations to reliable sources in this section. Unsourced material may be challenged and removed. (January 2025) (Learn how and when to remove this message)  Regexes are useful in a wide variety of text processing tasks, and more generally string processing, where the data need not be textual. Common applications include data validation, data scraping (especially web scraping), data wrangling, simple parsing, the production of syntax highlighting systems, and many other tasks.  Some high-end desktop publishing software has the ability to use regexes to automatically apply text styling, saving the person doing the layout from laboriously doing this by hand for anything that can be matched by a regex. For example, by defining a character style that makes text into small caps and then using the regex [A-Z]{4,} to apply that style, any word of four or more consecutive capital letters will be automatically rendered as small caps instead.  While regexes would be useful on Internet search engines, processing them across the entire database could consume excessive computer resources depending on the complexity and design of the regex. Although in many cases system administrators can run regex-based queries internally, most search engines do not offer regex support to the public. Notable exceptions include Google Code Search and Exalead. However, Google Code Search was shut down in January 2012.[59] Examples  The specific syntax rules vary depending on the specific implementation, programming language, or library in use. Additionally, the functionality of regex implementations can vary between versions.  Because regexes can be difficult to both explain and understand without examples, interactive websites for testing regexes are a useful resource for learning regexes by experimentation. This section provides a basic description of some of the properties of regexes by way of illustration.  The following conventions are used in the examples.[60]  metacharacter(s) ;; the metacharacters column specifies the regex syntax being demonstrated =~ m//           ;; indicates a regex match operation in Perl =~ s///          ;; indicates a regex substitution operation in Perl  These regexes are all Perl-like syntax. Standard POSIX regular expressions are different.  Unless otherwise indicated, the following examples conform to the Perl programming language, release 5.8.8, January 31, 2006. This means that other implementations may lack support for some parts of the syntax shown here (e.g. basic vs. extended regex, \( \) vs. (), or lack of \d instead of POSIX [:digit:]).  The syntax and conventions used in these examples coincide with that of other programming environments as well.[61] Meta­character(s) 	Description 	Example[62] . 	Normally matches any character except a newline. Within square brackets the dot is literal. 	  $string1 = "Hello World\n"; if ($string1 =~ m/...../) {   print "$string1 has length >= 5.\n"; }  Output:  Hello World  has length >= 5.  ( ) 	Groups a series of pattern elements to a single element. When you match a pattern within parentheses, you can use any of $1, $2, ... later to refer to the previously matched pattern. Some implementations may use a backslash notation instead, like \1, \2. 	  $string1 = "Hello World\n"; if ($string1 =~ m/(H..).(o..)/) {   print "We matched '$1' and '$2'.\n"; }  Output:  We matched 'Hel' and 'o W'.  + 	Matches the preceding pattern element one or more times. 	  $string1 = "Hello World\n"; if ($string1 =~ m/l+/) {   print "There are one or more consecutive letter \"l\"'s in $string1.\n"; }  Output:  There are one or more consecutive letter "l"'s in Hello World.  ? 	Matches the preceding pattern element zero or one time. 	  $string1 = "Hello World\n"; if ($string1 =~ m/H.?e/) {   print "There is an 'H' and a 'e' separated by ";   print "0-1 characters (e.g., He Hue Hee).\n"; }  Output:  There is an 'H' and a 'e' separated by 0-1 characters (e.g., He Hue Hee).  ? 	Modifies the *, +, ? or {M,N}'d regex that comes before to match as few times as possible. 	  $string1 = "Hello World\n"; if ($string1 =~ m/(l.+?o)/) {   print "The non-greedy match with 'l' followed by one or ";   print "more characters is 'llo' rather than 'llo Wo'.\n"; }  Output:  The non-greedy match with 'l' followed by one or more characters is 'llo' rather than 'llo Wo'.  * 	Matches the preceding pattern element zero or more times. 	  $string1 = "Hello World\n"; if ($string1 =~ m/el*o/) {   print "There is an 'e' followed by zero to many ";   print "'l' followed by 'o' (e.g., eo, elo, ello, elllo).\n"; }  Output:  There is an 'e' followed by zero to many 'l' followed by 'o' (e.g., eo, elo, ello, elllo).  {M,N} 	Denotes the minimum M and the maximum N match count. N can be omitted and M can be 0: {M} matches "exactly" M times; {M,} matches "at least" M times; {0,N} matches "at most" N times. x* y+ z? is thus equivalent to x{0,} y{1,} z{0,1}. 	  $string1 = "Hello World\n"; if ($string1 =~ m/l{1,2}/) {   print "There exists a substring with at least 1 ";   print "and at most 2 l's in $string1\n"; }  Output:  There exists a substring with at least 1 and at most 2 l's in Hello World  […] 	Denotes a set of possible character matches. 	  $string1 = "Hello World\n"; if ($string1 =~ m/[aeiou]+/) {   print "$string1 contains one or more vowels.\n"; }  Output:  Hello World  contains one or more vowels.  | 	Separates alternate possibilities. 	  $string1 = "Hello World\n"; if ($string1 =~ m/(Hello|Hi|Pogo)/) {   print "$string1 contains at least one of Hello, Hi, or Pogo."; }  Output:  Hello World  contains at least one of Hello, Hi, or Pogo.  \b 	Matches a zero-width boundary between a word-class character (see next) and either a non-word class character or an edge; same as  (^\w|\w$|\W\w|\w\W). 	  $string1 = "Hello World\n"; if ($string1 =~ m/llo\b/) {   print "There is a word that ends with 'llo'.\n"; }  Output:  There is a word that ends with 'llo'.  \w 	Matches an alphanumeric character, including "_"; same as [A-Za-z0-9_] in ASCII, and      [\p{Alphabetic}\p{GC=Mark}\p{GC=Decimal_Number}\p{GC=Connector_Punctuation}]  in Unicode,[58] where the Alphabetic property contains more than Latin letters, and the Decimal_Number property contains more than Arab digits. 	  $string1 = "Hello World\n"; if ($string1 =~ m/\w/) {   print "There is at least one alphanumeric ";   print "character in $string1 (A-Z, a-z, 0-9, _).\n"; }  Output:  There is at least one alphanumeric character in Hello World  (A-Z, a-z, 0-9, _).  \W 	Matches a non-alphanumeric character, excluding "_"; same as [^A-Za-z0-9_] in ASCII, and      [^\p{Alphabetic}\p{GC=Mark}\p{GC=Decimal_Number}\p{GC=Connector_Punctuation}]  in Unicode. 	  $string1 = "Hello World\n"; if ($string1 =~ m/\W/) {   print "The space between Hello and ";   print "World is not alphanumeric.\n"; }  Output:  The space between Hello and World is not alphanumeric.  \s 	Matches a whitespace character, which in ASCII are tab, line feed, form feed, carriage return, and space; in Unicode, also matches no-break spaces, next line, and the variable-width spaces (among others). 	  $string1 = "Hello World\n"; if ($string1 =~ m/\s.*\s/) {   print "In $string1 there are TWO whitespace characters, which may";   print " be separated by other characters.\n"; }  Output:  In Hello World  there are TWO whitespace characters, which may be separated by other characters.  \S 	Matches anything but a whitespace. 	  $string1 = "Hello World\n"; if ($string1 =~ m/\S.*\S/) {   print "In $string1 there are TWO non-whitespace characters, which";   print " may be separated by other characters.\n"; }  Output:  In Hello World  there are TWO non-whitespace characters, which may be separated by other characters.  \d 	Matches a digit; same as [0-9] in ASCII; in Unicode, same as the \p{Digit} or \p{GC=Decimal_Number} property, which itself the same as the \p{Numeric_Type=Decimal} property. 	  $string1 = "99 bottles of beer on the wall."; if ($string1 =~ m/(\d+)/) {   print "$1 is the first number in '$string1'\n"; }  Output:  99 is the first number in '99 bottles of beer on the wall.'  \D 	Matches a non-digit; same as [^0-9] in ASCII or \P{Digit} in Unicode. 	  $string1 = "Hello World\n"; if ($string1 =~ m/\D/) {   print "At least one character in $string1";   print " is not a digit.\n"; }  Output:  At least one character in Hello World  is not a digit.  ^ 	Matches the beginning of a line or string. 	  $string1 = "Hello World\n"; if ($string1 =~ m/^He/) {   print "$string1 starts with the characters 'He'.\n"; }  Output:  Hello World  starts with the characters 'He'.  $ 	Matches the end of a line or string. 	  $string1 = "Hello World\n"; if ($string1 =~ m/rld$/) {   print "$string1 is a line or string ";   print "that ends with 'rld'.\n"; }  Output:  Hello World  is a line or string that ends with 'rld'.  \A 	Matches the beginning of a string (but not an internal line). 	  $string1 = "Hello\nWorld\n"; if ($string1 =~ m/\AH/) {   print "$string1 is a string ";   print "that starts with 'H'.\n"; }  Output:  Hello World  is a string that starts with 'H'.  \z 	Matches the end of a string (but not an internal line).[63] 	  $string1 = "Hello\nWorld\n"; if ($string1 =~ m/d\n\z/) {   print "$string1 is a string ";   print "that ends with 'd\\n'.\n"; }  Output:  Hello World  is a string